const puzzle = `...1...........
..1000001000...
...0....0......
.1......0...1..
.0....100000000
100000..0...0..
.0.....1001000.
.0.1....0.0....
.10000000.0....
.0.0......0....
.0.0.....100...
...0......0....
..........0....`;

const words = [
  'sun',
  'sunglasses',
  'suncream',
  'swimming',
  'bikini',
  'beach',
  'icecream',
  'tan',
  'deckchair',
  'sand',
  'seaside',
  'sandals',
].reverse(); // Reversed order as required

// Set debug to true to see console.log outputs
const debug = false;

function solvePuzzle(puzzle, words) {
  // Parse the puzzle into a 2D grid.
  const grid = puzzle.split('\n').map(row => row.split(''));
  const rows = grid.length; // Number of rows
  const cols = grid[0].length; // Number of columns

  // Save a copy of the original grid so we know which cells were valid starting points.
  const original = puzzle.split('\n').map(row => row.split(''));

  // --- Helper: A cell is considered "empty" for placement if it is a dot or a digit.
  function cellMatches(cell, letter) {
    // If the cell is a dot or one of the digits, we consider it available.
    if (cell === '.' || cell === '0' || cell === '1' || cell === '2')
      return true;
    return cell === letter;
  }

  // --- Horizontal Placement Functions
  function isValidHorizontal(y, x, word) {
    if (x + word.length > cols) return false; // Would run off the right edge.
    for (let i = 0; i < word.length; i++) {
      if (!cellMatches(grid[y][x + i], word[i])) return false;
    }
    return true;
  }

  function placeHorizontal(y, x, word) {
    const positions = [];
    for (let i = 0; i < word.length; i++) {
      positions.push({ y: y, x: x + i, char: grid[y][x + i] });
      grid[y][x + i] = word[i];
    }
    if (debug) console.log(`Placed "${word}" horizontally at (${y}, ${x})`);
    return positions;
  }

  function removeHorizontal(positions, word) {
    for (let pos of positions) {
      grid[pos.y][pos.x] = pos.char;
    }
    if (debug)
      console.log(
        `Removed "${word}" horizontally from (${positions[0].y}, ${positions[0].x})`
      );
  }

  // --- Vertical Placement Functions
  function isValidVertical(y, x, word) {
    if (y + word.length > rows) return false; // Would run off the bottom edge.
    for (let i = 0; i < word.length; i++) {
      if (!cellMatches(grid[y + i][x], word[i])) return false;
    }
    return true;
  }

  function placeVertical(y, x, word) {
    const positions = [];
    for (let i = 0; i < word.length; i++) {
      positions.push({ y: y + i, x: x, char: grid[y + i][x] });
      grid[y + i][x] = word[i];
    }
    if (debug) console.log(`Placed "${word}" vertically at (${y}, ${x})`);
    return positions;
  }

  function removeVertical(positions, word) {
    for (let pos of positions) {
      grid[pos.y][pos.x] = pos.char;
    }
    if (debug)
      console.log(
        `Removed "${word}" vertically from (${positions[0].y}, ${positions[0].x})`
      );
  }

  // --- Backtracking Function
  // 'index' indicates which word (from the reversed list) we are trying to place.
  function backtrack(index = 0) {
    if (index === words.length) {
      if (debug) console.log('All words placed successfully.');
      return true; // All words placed.
    }

    const word = words[index];
    if (debug) console.log(`Trying to place word [${index}]: "${word}"`);

    // Try every cell in the grid as a candidate starting position.
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        // Only consider cells that originally were designated as starting points ('1' or '2').
        if (original[y][x] === '1' || original[y][x] === '2') {
          // Attempt horizontal placement.
          if (isValidHorizontal(y, x, word)) {
            if (debug)
              console.log(
                `Attempting horizontal placement of "${word}" at (${y}, ${x})`
              );
            const placed = placeHorizontal(y, x, word);
            if (backtrack(index + 1)) return true;
            removeHorizontal(placed, word);
          }
          // Attempt vertical placement.
          if (isValidVertical(y, x, word)) {
            if (debug)
              console.log(
                `Attempting vertical placement of "${word}" at (${y}, ${x})`
              );
            const placed = placeVertical(y, x, word);
            if (backtrack(index + 1)) return true;
            removeVertical(placed, word);
          }
        }
      }
    }
    if (debug) console.log(`Backtracking on word "${word}" at index ${index}`);
    return false; // No valid placement found for this word; backtrack.
  }

  // Start the backtracking process.
  backtrack();

  // Final cleanup: Replace any cell that is not a letter with a dot.
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      if (!/[A-Za-z]/.test(grid[y][x])) {
        grid[y][x] = '.';
      }
    }
  }

  // Convert the grid back into a string.
  return grid.map(row => row.join('')).join('\n');
}

// Run the solver and output the final grid.
const result = solvePuzzle(puzzle, words);
console.log('\nFinal Result:\n' + result);
